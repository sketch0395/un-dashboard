<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switch Connection Final Diagnosis</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background-color: #0056b3; }
        .fix-btn { background-color: #28a745; }
        .fix-btn:hover { background-color: #1e7e34; }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .data-display {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Switch Connection Final Diagnosis</h1>
        <p><strong>Task:</strong> Identify and fix why devices are not connecting to switches</p>

        <!-- Test Results Display -->
        <div id="results"></div>

        <!-- Action Buttons -->
        <div class="test-section info">
            <h3>üìã Test Actions</h3>
            <button onclick="runFullDiagnosis()">üîç Run Full Diagnosis</button>
            <button onclick="testManualWorkflow()">üëÜ Test Manual Workflow</button>
            <button onclick="validateDataIntegrity()">üîí Validate Data Integrity</button>
            <button onclick="simulateUserActions()">üé≠ Simulate User Actions</button>
            <button class="fix-btn" onclick="applyComprehensiveFix()">üîß Apply Comprehensive Fix</button>
        </div>

        <!-- Live Data Display -->
        <div class="test-section">
            <h3>üìä Live Data Display</h3>
            <div id="liveData" class="data-display"></div>
        </div>
    </div>

    <script>
        let testResults = [];
        let currentData = {};

        function log(message, type = 'info') {
            testResults.push({ message, type, timestamp: new Date().toISOString() });
            updateResultsDisplay();
        }

        function updateResultsDisplay() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = testResults.map(result => 
                `<div class="test-section ${result.type}">
                    <strong>[${new Date(result.timestamp).toLocaleTimeString()}]</strong> ${result.message}
                </div>`
            ).join('');
        }

        function updateLiveData() {
            const devices = JSON.parse(localStorage.getItem('devices') || '[]');
            const switches = devices.filter(d => d.type === 'switch' || d.type === 'gateway');
            const regularDevices = devices.filter(d => d.type !== 'switch' && d.type !== 'gateway');
            
            currentData = {
                totalDevices: devices.length,
                switches: switches.length,
                regularDevices: regularDevices.length,
                devicesWithSwitchConnections: regularDevices.filter(d => d.parentSwitch).length,
                switchesWithConnections: switches.filter(s => s.connectedSwitches && s.connectedSwitches.length > 0).length
            };

            document.getElementById('liveData').innerHTML = `
                <pre>${JSON.stringify(currentData, null, 2)}</pre>
                <h4>üì± Devices:</h4>
                <pre>${JSON.stringify(devices, null, 2)}</pre>
            `;
        }

        async function runFullDiagnosis() {
            log("üöÄ Starting comprehensive switch connection diagnosis...", 'info');
            
            // 1. Check localStorage data
            const devices = JSON.parse(localStorage.getItem('devices') || '[]');
            log(`üìä Found ${devices.length} total devices in localStorage`, devices.length > 0 ? 'success' : 'warning');
            
            const switches = devices.filter(d => d.type === 'switch' || d.type === 'gateway');
            const regularDevices = devices.filter(d => d.type !== 'switch' && d.type !== 'gateway');
            
            log(`üîå Found ${switches.length} switches/gateways`, switches.length > 0 ? 'success' : 'error');
            log(`üì± Found ${regularDevices.length} regular devices`, regularDevices.length > 0 ? 'success' : 'warning');

            // 2. Check if switches have proper IDs
            if (switches.length > 0) {
                const switchesWithIds = switches.filter(s => s.id);
                log(`‚úÖ Switches with IDs: ${switchesWithIds.length}/${switches.length}`, 
                    switchesWithIds.length === switches.length ? 'success' : 'error');
                
                if (switchesWithIds.length < switches.length) {
                    log("‚ùå ISSUE FOUND: Some switches are missing IDs!", 'error');
                }
            }

            // 3. Check device-switch relationships
            if (regularDevices.length > 0) {
                const devicesWithSwitchConnections = regularDevices.filter(d => d.parentSwitch);
                log(`üîó Devices with switch connections: ${devicesWithSwitchConnections.length}/${regularDevices.length}`, 
                    devicesWithSwitchConnections.length > 0 ? 'success' : 'warning');

                // Validate switch references
                for (const device of devicesWithSwitchConnections) {
                    const referencedSwitch = switches.find(s => s.id === device.parentSwitch);
                    if (!referencedSwitch) {
                        log(`‚ùå ISSUE FOUND: Device "${device.name}" references non-existent switch ID: ${device.parentSwitch}`, 'error');
                    } else {
                        log(`‚úÖ Device "${device.name}" correctly connected to switch "${referencedSwitch.name}"`, 'success');
                    }
                }
            }

            // 4. Check switch-to-switch connections
            for (const switchDevice of switches) {
                if (switchDevice.connectedSwitches && switchDevice.connectedSwitches.length > 0) {
                    log(`üîó Switch "${switchDevice.name}" has ${switchDevice.connectedSwitches.length} connections`, 'success');
                    
                    for (const connectedId of switchDevice.connectedSwitches) {
                        const connectedSwitch = switches.find(s => s.id === connectedId);
                        if (!connectedSwitch) {
                            log(`‚ùå ISSUE FOUND: Switch "${switchDevice.name}" references non-existent switch ID: ${connectedId}`, 'error');
                        }
                    }
                }
            }

            // 5. Test switch dropdown functionality
            if (switches.length === 0) {
                log("‚ùå CRITICAL ISSUE: No switches available for device connections! Users cannot connect devices to switches.", 'error');
                log("üí° FIX NEEDED: Create sample switches or ensure switch creation workflow works", 'warning');
            }

            // 6. Check for common data corruption issues
            const duplicateIds = [];
            const seenIds = new Set();
            for (const device of devices) {
                if (device.id && seenIds.has(device.id)) {
                    duplicateIds.push(device.id);
                } else if (device.id) {
                    seenIds.add(device.id);
                }
            }
            
            if (duplicateIds.length > 0) {
                log(`‚ùå ISSUE FOUND: Duplicate device IDs detected: ${duplicateIds.join(', ')}`, 'error');
            }

            updateLiveData();
            log("‚úÖ Diagnosis complete!", 'success');
        }

        async function testManualWorkflow() {
            log("üéØ Testing manual switch connection workflow...", 'info');
            
            // Clear existing data for clean test
            localStorage.removeItem('devices');
            log("üßπ Cleared existing data for clean test", 'info');
            
            // Create test switches
            const testSwitches = [
                {
                    id: 'switch-001',
                    name: 'Main Switch',
                    type: 'switch',
                    ip: '192.168.1.1',
                    connectedSwitches: []
                },
                {
                    id: 'switch-002', 
                    name: 'Secondary Switch',
                    type: 'switch',
                    ip: '192.168.1.2',
                    connectedSwitches: []
                }
            ];

            localStorage.setItem('devices', JSON.stringify(testSwitches));
            log("‚úÖ Created 2 test switches", 'success');

            // Create test devices and connect them
            const testDevices = [
                {
                    id: 'device-001',
                    name: 'Test Laptop',
                    type: 'laptop',
                    ip: '192.168.1.100',
                    parentSwitch: 'switch-001'
                },
                {
                    id: 'device-002',
                    name: 'Test Server',
                    type: 'server', 
                    ip: '192.168.1.101',
                    parentSwitch: 'switch-002'
                }
            ];

            const allDevices = [...testSwitches, ...testDevices];
            localStorage.setItem('devices', JSON.stringify(allDevices));
            log("‚úÖ Created 2 test devices connected to switches", 'success');

            // Verify connections
            const savedDevices = JSON.parse(localStorage.getItem('devices') || '[]');
            const connectedDevices = savedDevices.filter(d => d.parentSwitch);
            
            if (connectedDevices.length === 2) {
                log("‚úÖ Manual workflow test PASSED - devices successfully connected to switches", 'success');
            } else {
                log("‚ùå Manual workflow test FAILED - device connections not saved properly", 'error');
            }

            updateLiveData();
        }

        async function validateDataIntegrity() {
            log("üîç Validating data integrity...", 'info');
            
            const devices = JSON.parse(localStorage.getItem('devices') || '[]');
            let issues = 0;

            // Check for required fields
            for (const device of devices) {
                if (!device.id) {
                    log(`‚ùå Device missing ID: ${JSON.stringify(device)}`, 'error');
                    issues++;
                }
                if (!device.name) {
                    log(`‚ùå Device missing name: ${JSON.stringify(device)}`, 'error');
                    issues++;
                }
                if (!device.type) {
                    log(`‚ùå Device missing type: ${JSON.stringify(device)}`, 'error');
                    issues++;
                }
            }

            // Check relationship integrity
            const switchIds = new Set(devices.filter(d => d.type === 'switch' || d.type === 'gateway').map(d => d.id));
            
            for (const device of devices) {
                if (device.parentSwitch && !switchIds.has(device.parentSwitch)) {
                    log(`‚ùå Device "${device.name}" references invalid switch ID: ${device.parentSwitch}`, 'error');
                    issues++;
                }
                
                if (device.connectedSwitches) {
                    for (const connectedId of device.connectedSwitches) {
                        if (!switchIds.has(connectedId)) {
                            log(`‚ùå Switch "${device.name}" references invalid switch ID: ${connectedId}`, 'error');
                            issues++;
                        }
                    }
                }
            }

            if (issues === 0) {
                log("‚úÖ Data integrity validation PASSED", 'success');
            } else {
                log(`‚ùå Data integrity validation FAILED with ${issues} issues`, 'error');
            }
        }

        async function simulateUserActions() {
            log("üé≠ Simulating typical user actions...", 'info');
            
            // Simulate user creating a switch
            log("üë§ User creates a new switch...", 'info');
            const newSwitch = {
                id: `switch-${Date.now()}`,
                name: 'User Created Switch',
                type: 'switch',
                ip: '192.168.1.50',
                connectedSwitches: []
            };
            
            const existingDevices = JSON.parse(localStorage.getItem('devices') || '[]');
            existingDevices.push(newSwitch);
            localStorage.setItem('devices', JSON.stringify(existingDevices));
            log("‚úÖ Switch created successfully", 'success');

            // Simulate user creating a device and connecting it
            log("üë§ User creates a device and connects it to the switch...", 'info');
            const newDevice = {
                id: `device-${Date.now()}`,
                name: 'User Created Device',
                type: 'laptop',
                ip: '192.168.1.150',
                parentSwitch: newSwitch.id
            };
            
            const updatedDevices = JSON.parse(localStorage.getItem('devices') || '[]');
            updatedDevices.push(newDevice);
            localStorage.setItem('devices', JSON.stringify(updatedDevices));
            log("‚úÖ Device created and connected successfully", 'success');

            // Verify the connection was saved
            const finalDevices = JSON.parse(localStorage.getItem('devices') || '[]');
            const createdDevice = finalDevices.find(d => d.id === newDevice.id);
            
            if (createdDevice && createdDevice.parentSwitch === newSwitch.id) {
                log("‚úÖ User action simulation PASSED - connection persisted correctly", 'success');
            } else {
                log("‚ùå User action simulation FAILED - connection not saved", 'error');
            }

            updateLiveData();
        }

        async function applyComprehensiveFix() {
            log("üîß Applying comprehensive fix for switch connection issues...", 'info');
            
            const devices = JSON.parse(localStorage.getItem('devices') || '[]');
            let fixedIssues = 0;

            // Fix 1: Ensure all devices have unique IDs
            const usedIds = new Set();
            for (const device of devices) {
                if (!device.id || usedIds.has(device.id)) {
                    device.id = `${device.type || 'device'}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    fixedIssues++;
                }
                usedIds.add(device.id);
            }

            // Fix 2: Clean up invalid switch references
            const validSwitchIds = new Set(devices.filter(d => d.type === 'switch' || d.type === 'gateway').map(d => d.id));
            
            for (const device of devices) {
                if (device.parentSwitch && !validSwitchIds.has(device.parentSwitch)) {
                    log(`üîß Removing invalid switch reference from device "${device.name}"`, 'warning');
                    delete device.parentSwitch;
                    fixedIssues++;
                }
                
                if (device.connectedSwitches) {
                    const validConnections = device.connectedSwitches.filter(id => validSwitchIds.has(id));
                    if (validConnections.length !== device.connectedSwitches.length) {
                        device.connectedSwitches = validConnections;
                        fixedIssues++;
                    }
                }
            }

            // Fix 3: Ensure switches exist if needed
            const switches = devices.filter(d => d.type === 'switch' || d.type === 'gateway');
            if (switches.length === 0) {
                log("üîß No switches found - creating default switches", 'info');
                const defaultSwitches = [
                    {
                        id: 'switch-default-main',
                        name: 'Main Network Switch',
                        type: 'switch',
                        ip: '192.168.1.1',
                        connectedSwitches: []
                    },
                    {
                        id: 'switch-default-secondary',
                        name: 'Secondary Switch',
                        type: 'switch', 
                        ip: '192.168.1.2',
                        connectedSwitches: []
                    }
                ];
                devices.push(...defaultSwitches);
                fixedIssues += 2;
            }

            // Save fixed data
            localStorage.setItem('devices', JSON.stringify(devices));
            
            log(`‚úÖ Comprehensive fix applied! Fixed ${fixedIssues} issues.`, 'success');
            log("üîÑ Please test switch connections again in the application", 'info');
            
            updateLiveData();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateLiveData();
            log("üéØ Switch Connection Final Diagnosis Tool Ready", 'info');
            log("üìù Use the buttons above to run diagnostics and fixes", 'info');
        });

        // Auto-refresh data every 5 seconds
        setInterval(updateLiveData, 5000);
    </script>
</body>
</html>
