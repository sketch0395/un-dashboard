<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Scan Export Functionality Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: #2a2a2a;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success {
            background-color: #2d5a27;
            border: 1px solid #4caf50;
        }
        .error {
            background-color: #5a2d27;
            border: 1px solid #f44336;
        }
        .info {
            background-color: #27435a;
            border: 1px solid #2196f3;
        }
        button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #005999;
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        .log {
            background-color: #1e1e1e;
            border: 1px solid #444;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>Network Scan Export Functionality Test</h1>
    <p>This page tests the export functionality and scan duplication prevention fixes.</p>

    <div class="test-section">
        <h2>Test 1: Scan Duplication Prevention</h2>
        <p>This test checks if duplicate scans are properly prevented.</p>
        <button onclick="testScanDuplication()">Test Scan Duplication Prevention</button>
        <div id="duplication-results"></div>
        <div id="duplication-log" class="log"></div>
    </div>

    <div class="test-section">
        <h2>Test 2: Export Functionality</h2>
        <p>This test verifies that custom device properties and network hierarchy are included in exports.</p>
        <button onclick="testExportFunctionality()">Test Export Functionality</button>
        <div id="export-results"></div>
        <div id="export-log" class="log"></div>
    </div>    <div class="test-section">
        <h2>Test 3: Import/Export Round Trip</h2>
        <p>This test performs a full import/export cycle to verify data integrity.</p>
        <button onclick="testImportExportRoundTrip()">Test Import/Export Round Trip</button>
        <div id="roundtrip-results"></div>
        <div id="roundtrip-log" class="log"></div>
    </div>

    <div class="test-section">
        <h2>Test 4: Device History Preservation</h2>
        <p>This test verifies that device history information is properly preserved during import operations.</p>
        <button onclick="testDeviceHistoryPreservation()">Test Device History Preservation</button>
        <div id="history-results"></div>
        <div id="history-log" class="log"></div>
    </div>

    <div class="test-section">
        <h2>Manual Test Instructions</h2>
        <div class="info">
            <h3>Manual Test Steps:</h3>
            <ol>
                <li>Go to <a href="http://localhost:3000/networkscan" target="_blank">Network Scan Page</a></li>
                <li>Run a network scan (ping or OS detection)</li>
                <li>Check scan history - verify no duplicates appear</li>
                <li>Select 1+ scans from history</li>
                <li>Use "Export Selected Scans" functionality</li>
                <li>Verify exported file contains custom device properties</li>
                <li>Import the exported file back</li>
                <li>Verify network hierarchy properties are preserved</li>
            </ol>
        </div>
    </div>

    <script>
        function log(elementId, message) {
            const logElement = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function addResult(elementId, message, type = 'info') {
            const resultElement = document.getElementById(elementId);
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            resultElement.appendChild(div);
        }

        async function testScanDuplication() {
            const resultsId = 'duplication-results';
            const logId = 'duplication-log';
            
            document.getElementById(resultsId).innerHTML = '';
            document.getElementById(logId).innerHTML = '';
            
            log(logId, 'Starting scan duplication prevention test...');
            
            try {
                // Check localStorage for existing scan history
                const existingHistory = JSON.parse(localStorage.getItem('scanHistory') || '[]');
                log(logId, `Found ${existingHistory.length} existing scans in history`);
                
                // Create test scan data
                const testScanData = {
                    "Unknown": [
                        {
                            ip: "10.5.1.1",
                            status: "online",
                            vendor: "Test Vendor",
                            mac: "00:11:22:33:44:55",
                            ports: ["22/tcp open", "80/tcp open"]
                        }
                    ]
                };
                
                // Simulate multiple rapid saves (what was causing duplication)
                log(logId, 'Simulating rapid duplicate save attempts...');
                
                // Get the saveScanHistory function (this would normally be from React context)
                const mockSaveScanHistory = (data, ipRange) => {
                    const deviceCount = Object.values(data).flat().length;
                    const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
                    
                    // Check for duplicates within the last 5 minutes
                    const history = JSON.parse(localStorage.getItem('scanHistory') || '[]');
                    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
                    
                    const isDuplicate = history.some(entry => {
                        const entryTime = new Date(entry.timestamp);
                        const timeDifference = Math.abs(new Date() - entryTime);
                        
                        return (
                            timeDifference < 5 * 60 * 1000 && // Within 5 minutes
                            entry.devices === deviceCount && // Same number of devices
                            entry.ipRange === ipRange && // Same IP range
                            JSON.stringify(entry.data) === JSON.stringify(data) // Same data
                        );
                    });
                    
                    if (isDuplicate) {
                        log(logId, `Duplicate scan detected and prevented: ${deviceCount} devices, ${ipRange}`);
                        return false; // Duplicate prevented
                    }
                    
                    const newEntry = {
                        id: 'test-' + Math.random().toString(36).substring(2, 9),
                        timestamp,
                        ipRange,
                        devices: deviceCount,
                        data,
                    };
                    
                    history.push(newEntry);
                    localStorage.setItem('scanHistory', JSON.stringify(history));
                    log(logId, `New scan added to history: ${newEntry.id}`);
                    return true; // New scan added
                };
                
                // Test 1: First save should succeed
                const firstSave = mockSaveScanHistory(testScanData, "10.5.1.1-255");
                if (firstSave) {
                    addResult(resultsId, "✓ First scan save succeeded", "success");
                } else {
                    addResult(resultsId, "✗ First scan save failed", "error");
                }
                
                // Test 2: Immediate duplicate should be prevented
                const duplicateSave = mockSaveScanHistory(testScanData, "10.5.1.1-255");
                if (!duplicateSave) {
                    addResult(resultsId, "✓ Duplicate scan was properly prevented", "success");
                } else {
                    addResult(resultsId, "✗ Duplicate scan was not prevented", "error");
                }
                
                // Test 3: Different data should be allowed
                const differentData = {
                    "Unknown": [
                        {
                            ip: "10.5.1.2",
                            status: "online",
                            vendor: "Different Vendor",
                            mac: "00:11:22:33:44:66",
                            ports: ["22/tcp open"]
                        }
                    ]
                };
                
                const differentSave = mockSaveScanHistory(differentData, "10.5.1.1-255");
                if (differentSave) {
                    addResult(resultsId, "✓ Different scan data was properly allowed", "success");
                } else {
                    addResult(resultsId, "✗ Different scan data was incorrectly rejected", "error");
                }
                
                log(logId, 'Scan duplication prevention test completed');
                
            } catch (error) {
                addResult(resultsId, `Error during test: ${error.message}`, "error");
                log(logId, `Error: ${error.message}`);
            }
        }

        async function testExportFunctionality() {
            const resultsId = 'export-results';
            const logId = 'export-log';
            
            document.getElementById(resultsId).innerHTML = '';
            document.getElementById(logId).innerHTML = '';
            
            log(logId, 'Starting export functionality test...');
            
            try {
                // Create test data with custom properties
                const testCustomProperties = {
                    "10.5.1.1": {
                        name: "Main Gateway",
                        networkRole: "gateway",
                        isMainGateway: true,
                        parentGateway: null,
                        portCount: 24,
                        category: "Network Infrastructure",
                        notes: "Primary network gateway"
                    },
                    "10.5.1.10": {
                        name: "Core Switch",
                        networkRole: "switch",
                        isMainGateway: false,
                        parentGateway: "10.5.1.1",
                        portCount: 48,
                        category: "Network Infrastructure",
                        notes: "Core network switch"
                    }
                };
                
                // Save test custom properties
                localStorage.setItem('customDeviceProperties', JSON.stringify(testCustomProperties));
                log(logId, 'Test custom properties saved to localStorage');
                
                const testScanData = {
                    "Unknown": [
                        {
                            ip: "10.5.1.1",
                            status: "online",
                            vendor: "Cisco",
                            mac: "00:11:22:33:44:55",
                            ports: ["22/tcp open", "80/tcp open", "443/tcp open"]
                        },
                        {
                            ip: "10.5.1.10",
                            status: "online", 
                            vendor: "HP",
                            mac: "00:11:22:33:44:66",
                            ports: ["22/tcp open", "80/tcp open"]
                        }
                    ]
                };
                
                // Test the export data enhancement
                const exportData = {
                    devices: testScanData,
                    customNames: testCustomProperties,
                    isSelectedScans: false,
                    scanCount: 1
                };
                
                // Simulate the enhancement process (from getSelectedScansData)
                const enhancedDevices = Object.values(testScanData).flat().map(device => {
                    const enhancedDevice = { ...device };
                    
                    if (device.ip && testCustomProperties[device.ip]) {
                        const customProps = testCustomProperties[device.ip];
                        
                        // Apply network hierarchy properties - CRITICAL for export
                        enhancedDevice.name = customProps.name || enhancedDevice.name;
                        enhancedDevice.networkRole = customProps.networkRole;
                        enhancedDevice.isMainGateway = customProps.isMainGateway;
                        enhancedDevice.parentGateway = customProps.parentGateway;
                        enhancedDevice.portCount = customProps.portCount;
                        enhancedDevice.category = customProps.category;
                        enhancedDevice.notes = customProps.notes;
                    }
                    
                    return enhancedDevice;
                });
                
                log(logId, `Enhanced ${enhancedDevices.length} devices with custom properties`);
                
                // Verify enhanced data contains custom properties
                const gatewayDevice = enhancedDevices.find(d => d.ip === "10.5.1.1");
                const switchDevice = enhancedDevices.find(d => d.ip === "10.5.1.10");
                
                if (gatewayDevice && gatewayDevice.networkRole === "gateway") {
                    addResult(resultsId, "✓ Gateway device has correct network role", "success");
                } else {
                    addResult(resultsId, "✗ Gateway device missing network role", "error");
                }
                
                if (gatewayDevice && gatewayDevice.isMainGateway === true) {
                    addResult(resultsId, "✓ Gateway device has correct isMainGateway flag", "success");
                } else {
                    addResult(resultsId, "✗ Gateway device missing isMainGateway flag", "error");
                }
                
                if (switchDevice && switchDevice.parentGateway === "10.5.1.1") {
                    addResult(resultsId, "✓ Switch device has correct parent gateway", "success");
                } else {
                    addResult(resultsId, "✗ Switch device missing parent gateway", "error");
                }
                
                if (switchDevice && switchDevice.portCount === 48) {
                    addResult(resultsId, "✓ Switch device has correct port count", "success");
                } else {
                    addResult(resultsId, "✗ Switch device missing port count", "error");
                }
                
                // Test JSON export format
                const jsonExport = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        exportType: "network-scan",
                        hasNetworkTopology: true,
                        scanCount: 1
                    },
                    devices: testScanData,
                    customNames: testCustomProperties
                };
                
                const jsonString = JSON.stringify(jsonExport, null, 2);
                log(logId, `JSON export size: ${jsonString.length} characters`);
                
                if (jsonString.includes('"networkRole"')) {
                    addResult(resultsId, "✓ JSON export contains network role data", "success");
                } else {
                    addResult(resultsId, "✗ JSON export missing network role data", "error");
                }
                
                if (jsonString.includes('"isMainGateway"')) {
                    addResult(resultsId, "✓ JSON export contains gateway flags", "success");
                } else {
                    addResult(resultsId, "✗ JSON export missing gateway flags", "error");
                }
                
                log(logId, 'Export functionality test completed');
                
            } catch (error) {
                addResult(resultsId, `Error during test: ${error.message}`, "error");
                log(logId, `Error: ${error.message}`);
            }
        }

        async function testImportExportRoundTrip() {
            const resultsId = 'roundtrip-results';
            const logId = 'roundtrip-log';
            
            document.getElementById(resultsId).innerHTML = '';
            document.getElementById(logId).innerHTML = '';
            
            log(logId, 'Starting import/export round trip test...');
            
            try {
                // Create complete test data
                const originalCustomProperties = {
                    "10.5.1.1": {
                        name: "Test Gateway",
                        networkRole: "gateway",
                        isMainGateway: true,
                        parentGateway: null,
                        parentSwitch: null,
                        portCount: 24,
                        category: "Network Infrastructure",
                        notes: "Test gateway device"
                    }
                };
                
                const originalScanData = {
                    "Cisco": [
                        {
                            ip: "10.5.1.1",
                            status: "online",
                            vendor: "Cisco",
                            mac: "00:11:22:33:44:55",
                            ports: ["22/tcp open", "80/tcp open"]
                        }
                    ]
                };
                
                // Step 1: Create export data
                const exportData = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        exportType: "network-scan",
                        hasNetworkTopology: true,
                        ipRange: "10.5.1.1-255"
                    },
                    devices: originalScanData,
                    customNames: originalCustomProperties
                };
                
                log(logId, 'Created export data with network topology');
                
                // Step 2: Simulate JSON export/import cycle
                const jsonString = JSON.stringify(exportData, null, 2);
                const parsedData = JSON.parse(jsonString);
                
                log(logId, 'Performed JSON serialization round trip');
                
                // Step 3: Verify data integrity
                if (JSON.stringify(parsedData.devices) === JSON.stringify(originalScanData)) {
                    addResult(resultsId, "✓ Device data survived round trip", "success");
                } else {
                    addResult(resultsId, "✗ Device data corrupted during round trip", "error");
                }
                
                if (JSON.stringify(parsedData.customNames) === JSON.stringify(originalCustomProperties)) {
                    addResult(resultsId, "✓ Custom properties survived round trip", "success");
                } else {
                    addResult(resultsId, "✗ Custom properties corrupted during round trip", "error");
                }
                
                if (parsedData.metadata && parsedData.metadata.hasNetworkTopology) {
                    addResult(resultsId, "✓ Network topology metadata preserved", "success");
                } else {
                    addResult(resultsId, "✗ Network topology metadata lost", "error");
                }
                
                // Step 4: Test enhancement process
                const enhancedDevices = Object.values(parsedData.devices).flat().map(device => {
                    const enhancedDevice = { ...device };
                    
                    if (device.ip && parsedData.customNames[device.ip]) {
                        const customProps = parsedData.customNames[device.ip];
                        if (customProps.networkRole !== undefined) enhancedDevice.networkRole = customProps.networkRole;
                        if (customProps.isMainGateway !== undefined) enhancedDevice.isMainGateway = customProps.isMainGateway;
                        if (customProps.parentGateway !== undefined) enhancedDevice.parentGateway = customProps.parentGateway;
                        if (customProps.parentSwitch !== undefined) enhancedDevice.parentSwitch = customProps.parentSwitch;
                        if (customProps.portCount !== undefined) enhancedDevice.portCount = customProps.portCount;
                    }
                    
                    return enhancedDevice;
                });
                
                const testDevice = enhancedDevices.find(d => d.ip === "10.5.1.1");
                if (testDevice && testDevice.networkRole === "gateway" && testDevice.isMainGateway === true) {
                    addResult(resultsId, "✓ Enhanced device has all network properties", "success");
                } else {
                    addResult(resultsId, "✗ Enhanced device missing network properties", "error");
                }
                
                log(logId, 'Import/export round trip test completed');
                
            } catch (error) {
                addResult(resultsId, `Error during test: ${error.message}`, "error");
                log(logId, `Error: ${error.message}`);
            }        }

        async function testDeviceHistoryPreservation() {
            const resultsId = 'history-results';
            const logId = 'history-log';
            
            document.getElementById(resultsId).innerHTML = '';
            document.getElementById(logId).innerHTML = '';
            
            log(logId, 'Starting device history preservation test...');
            
            try {
                // Step 1: Create test data with device history
                const testCustomProperties = {
                    "10.5.1.100": {
                        name: "Test Device with History",
                        networkRole: "workstation",
                        category: "Test Device",
                        history: [
                            {
                                timestamp: "2025-01-06 10:30:00",
                                changes: {
                                    name: "Test Device with History",
                                    networkRole: "workstation"
                                }
                            },
                            {
                                timestamp: "2025-01-06 11:15:00",
                                changes: {
                                    category: "Test Device"
                                }
                            }
                        ]
                    }
                };
                
                const testDeviceData = {
                    "Test Vendor": [
                        {
                            ip: "10.5.1.100",
                            status: "online",
                            vendor: "Test Vendor",
                            mac: "00:11:22:33:44:77",
                            ports: ["22/tcp open"],
                            history: [
                                {
                                    timestamp: "2025-01-06 10:30:00",
                                    changes: {
                                        name: "Test Device with History",
                                        networkRole: "workstation"
                                    }
                                },
                                {
                                    timestamp: "2025-01-06 11:15:00",
                                    changes: {
                                        category: "Test Device"
                                    }
                                }
                            ]
                        }
                    ]
                };
                
                log(logId, 'Created test data with device history');
                
                // Step 2: Create export data structure
                const exportData = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        exportType: "network-scan",
                        hasNetworkTopology: true,
                        ipRange: "10.5.1.1-255"
                    },
                    devices: testDeviceData,
                    customNames: testCustomProperties
                };
                
                log(logId, 'Export data structure created');
                
                // Step 3: Simulate parseJSONImport function (with our fix)
                const mockParseJSONImport = (jsonData) => {
                    // Validate device data format
                    let validDevices = jsonData.devices;
                    
                    // Check if we need to reconstruct customNames from devices with embedded properties
                    let customNamesData = jsonData.customNames || {};
                    
                    // If no customNames but devices have network topology properties, rebuild them
                    if (Object.keys(customNamesData).length === 0) {
                        const flattenedDevices = Object.values(validDevices).flat();
                            
                        flattenedDevices.forEach(device => {
                            if (device.ip && (
                                device.name || 
                                device.networkRole || 
                                device.isMainGateway || 
                                device.category ||
                                device.parentGateway ||
                                device.parentSwitch ||
                                device.portCount
                            )) {
                                customNamesData[device.ip] = {
                                    name: device.name || device.ip,
                                    category: device.category || '',
                                    notes: device.notes || [],
                                    networkRole: device.networkRole || null,
                                    isMainGateway: device.isMainGateway || false,
                                    parentGateway: device.parentGateway || null,
                                    parentSwitch: device.parentSwitch || null,
                                    portCount: device.portCount || null,
                                    history: device.history || [] // CRITICAL: Preserve device history data
                                };
                            }
                        });
                    }
                    
                    // IMPORTANT: Even if customNames exists, ensure history is preserved from devices
                    // This handles cases where the exported data has history in both places
                    if (Object.keys(customNamesData).length > 0) {
                        const flattenedDevices = Object.values(validDevices).flat();
                            
                        flattenedDevices.forEach(device => {
                            if (device.ip && customNamesData[device.ip] && device.history) {
                                // Merge history from device if it exists and is more complete
                                if (!customNamesData[device.ip].history || 
                                    (Array.isArray(device.history) && device.history.length > 0)) {
                                    customNamesData[device.ip].history = device.history;
                                }
                            }
                        });
                    }
                    
                    return {
                        devices: validDevices,
                        customNames: customNamesData,
                        metadata: jsonData.metadata
                    };
                };
                
                // Step 4: Test the import with our fix
                const importResult = mockParseJSONImport(exportData);
                
                log(logId, 'Performed import with parseJSONImport function');
                
                // Step 5: Verify history preservation
                const importedDevice = importResult.customNames["10.5.1.100"];
                
                if (importedDevice && importedDevice.history) {
                    if (Array.isArray(importedDevice.history) && importedDevice.history.length > 0) {
                        addResult(resultsId, "✓ Device history array preserved during import", "success");
                        log(logId, `Device history contains ${importedDevice.history.length} entries`);
                    } else {
                        addResult(resultsId, "✗ Device history array is empty", "error");
                    }
                } else {
                    addResult(resultsId, "✗ Device history completely missing after import", "error");
                }
                
                // Step 6: Verify specific history entries
                if (importedDevice && importedDevice.history && importedDevice.history.length >= 2) {
                    const firstEntry = importedDevice.history[0];
                    const secondEntry = importedDevice.history[1];
                    
                    if (firstEntry.timestamp && firstEntry.changes) {
                        addResult(resultsId, "✓ History entry structure preserved (timestamp + changes)", "success");
                    } else {
                        addResult(resultsId, "✗ History entry structure damaged", "error");
                    }
                    
                    if (firstEntry.changes.name === "Test Device with History") {
                        addResult(resultsId, "✓ History change data preserved correctly", "success");
                    } else {
                        addResult(resultsId, "✗ History change data corrupted", "error");
                    }
                    
                    if (secondEntry.changes.category === "Test Device") {
                        addResult(resultsId, "✓ Multiple history entries preserved", "success");
                    } else {
                        addResult(resultsId, "✗ Multiple history entries not preserved", "error");
                    }
                } else {
                    addResult(resultsId, "✗ Insufficient history entries preserved", "error");
                }
                
                // Step 7: Test the old broken behavior (to confirm the fix)
                const mockOldParseJSONImport = (jsonData) => {
                    let validDevices = jsonData.devices;
                    let customNamesData = jsonData.customNames || {};
                    
                    // Old broken logic (missing history preservation)
                    if (Object.keys(customNamesData).length === 0) {
                        const flattenedDevices = Object.values(validDevices).flat();
                            
                        flattenedDevices.forEach(device => {
                            if (device.ip && (device.name || device.networkRole || device.category)) {
                                customNamesData[device.ip] = {
                                    name: device.name || device.ip,
                                    category: device.category || '',
                                    notes: device.notes || [],
                                    networkRole: device.networkRole || null,
                                    // Missing: history: device.history || []
                                };
                            }
                        });
                    }
                    
                    return {
                        devices: validDevices,
                        customNames: customNamesData,
                        metadata: jsonData.metadata
                    };
                };
                
                const oldImportResult = mockOldParseJSONImport(exportData);
                const oldImportedDevice = oldImportResult.customNames["10.5.1.100"];
                
                if (!oldImportedDevice || !oldImportedDevice.history || oldImportedDevice.history.length === 0) {
                    addResult(resultsId, "✓ Confirmed: Old logic would lose device history", "success");
                    log(logId, 'Verified that the old implementation loses history');
                } else {
                    addResult(resultsId, "? Old logic unexpectedly preserved history", "info");
                }
                
                log(logId, 'Device history preservation test completed');
                
            } catch (error) {
                addResult(resultsId, `Error during test: ${error.message}`, "error");
                log(logId, `Error: ${error.message}`);
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            const timestamp = new Date().toLocaleString();
            document.querySelector('h1').textContent += ` - ${timestamp}`;
        });
        });
    </script>
</body>
</html>
