<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Import Fix Verification Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: #2a2a2a;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success {
            background-color: #2d5a27;
            border: 1px solid #4caf50;
        }
        .error {
            background-color: #5a2d27;
            border: 1px solid #f44336;
        }
        .info {
            background-color: #27435a;
            border: 1px solid #2196f3;
        }
        button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #005999;
        }
        .log {
            background-color: #1e1e1e;
            border: 1px solid #444;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .file-input {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Import Fix Verification Test</h1>
    <p>This test verifies that our fix for device history preservation during import operations is working correctly.</p>

    <div class="test-section">
        <h2>Test Real Import File</h2>
        <p>Select a JSON export file to test the import functionality:</p>
        <div class="file-input">
            <input type="file" id="importFile" accept=".json" onchange="testRealImportFile(event)">
        </div>
        <button onclick="testSampleData()">Test with Sample Data</button>
        <div id="import-results"></div>
        <div id="import-log" class="log"></div>
    </div>

    <script>
        function log(message) {
            const logElement = document.getElementById('import-log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function addResult(message, type = 'info') {
            const resultElement = document.getElementById('import-results');
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            resultElement.appendChild(div);
        }

        function clearResults() {
            document.getElementById('import-results').innerHTML = '';
            document.getElementById('import-log').textContent = '';
        }

        // Updated parseJSONImport function with our fix
        function parseJSONImport(jsonData) {
            try {
                // Validate that the data has the expected structure
                if (!jsonData.devices) {
                    throw new Error('Invalid JSON format: missing devices');
                }

                // Validate device data format
                let validDevices;
                if (Array.isArray(jsonData.devices)) {
                    // Convert array to expected object format with IP as key
                    validDevices = {};
                    jsonData.devices.forEach(device => {
                        if (device && device.ip) {
                            if (!validDevices[device.ip]) {
                                validDevices[device.ip] = [];
                            }
                            validDevices[device.ip].push(device);
                        }
                    });
                } else if (typeof jsonData.devices === 'object') {
                    // Already in expected format
                    validDevices = jsonData.devices;
                } else {
                    throw new Error('Invalid device data format');
                }

                // Check if we need to reconstruct customNames from devices with embedded properties
                let customNamesData = jsonData.customNames || {};
                
                // If no customNames but devices have network topology properties, rebuild them
                if (Object.keys(customNamesData).length === 0) {
                    const flattenedDevices = Array.isArray(jsonData.devices) 
                        ? jsonData.devices 
                        : Object.values(validDevices).flat();
                        
                    flattenedDevices.forEach(device => {
                        if (device.ip && (
                            device.name || 
                            device.networkRole || 
                            device.isMainGateway || 
                            device.category ||
                            device.parentGateway ||
                            device.parentSwitch ||
                            device.portCount
                        )) {
                            customNamesData[device.ip] = {
                                name: device.name || device.ip,
                                category: device.category || '',
                                notes: device.notes || [],
                                networkRole: device.networkRole || null,
                                isMainGateway: device.isMainGateway || false,
                                parentGateway: device.parentGateway || null,
                                parentSwitch: device.parentSwitch || null,
                                portCount: device.portCount || null,
                                history: device.history || [] // CRITICAL: Preserve device history data
                            };
                        }
                    });
                }
                
                // IMPORTANT: Even if customNames exists, ensure history is preserved from devices
                // This handles cases where the exported data has history in both places
                if (Object.keys(customNamesData).length > 0) {
                    const flattenedDevices = Array.isArray(jsonData.devices) 
                        ? jsonData.devices 
                        : Object.values(validDevices).flat();
                        
                    flattenedDevices.forEach(device => {
                        if (device.ip && customNamesData[device.ip] && device.history) {
                            // Merge history from device if it exists and is more complete
                            if (!customNamesData[device.ip].history || 
                                (Array.isArray(device.history) && device.history.length > 0)) {
                                customNamesData[device.ip].history = device.history;
                            }
                        }
                    });
                }

                // Return the parsed and validated data
                return {
                    devices: validDevices,
                    customNames: customNamesData,
                    metadata: jsonData.metadata || {}
                };
            } catch (error) {
                console.error('Error parsing JSON import:', error);
                throw error;
            }
        }

        async function testRealImportFile(event) {
            clearResults();
            log('Starting real import file test...');

            const file = event.target.files[0];
            if (!file) {
                addResult('No file selected', 'error');
                return;
            }

            try {
                const fileContent = await file.text();
                const jsonData = JSON.parse(fileContent);
                
                log(`Loaded file: ${file.name} (${fileContent.length} characters)`);
                log(`JSON structure: devices=${typeof jsonData.devices}, customNames=${typeof jsonData.customNames}`);
                
                // Test the import function
                const importResult = parseJSONImport(jsonData);
                
                log('Import function completed successfully');
                
                // Analyze the results
                const deviceCount = Object.keys(importResult.devices).length;
                const customNameCount = Object.keys(importResult.customNames).length;
                
                addResult(`✓ Successfully imported ${deviceCount} device groups`, 'success');
                addResult(`✓ Successfully imported ${customNameCount} custom device properties`, 'success');
                
                // Check for device history preservation
                let devicesWithHistory = 0;
                let totalHistoryEntries = 0;
                
                Object.entries(importResult.customNames).forEach(([ip, props]) => {
                    if (props.history && Array.isArray(props.history) && props.history.length > 0) {
                        devicesWithHistory++;
                        totalHistoryEntries += props.history.length;
                        log(`Device ${ip} (${props.name || 'unnamed'}) has ${props.history.length} history entries`);
                    }
                });
                
                if (devicesWithHistory > 0) {
                    addResult(`✓ Found ${devicesWithHistory} devices with preserved history (${totalHistoryEntries} total entries)`, 'success');
                } else {
                    addResult('ℹ No devices with history found in this file', 'info');
                }
                
                // Check for network topology data
                let devicesWithTopology = 0;
                Object.entries(importResult.customNames).forEach(([ip, props]) => {
                    if (props.networkRole || props.parentGateway || props.parentSwitch || props.isMainGateway) {
                        devicesWithTopology++;
                    }
                });
                
                if (devicesWithTopology > 0) {
                    addResult(`✓ Found ${devicesWithTopology} devices with network topology data`, 'success');
                } else {
                    addResult('ℹ No network topology data found in this file', 'info');
                }
                
                // Show sample data
                if (customNameCount > 0) {
                    const sampleIp = Object.keys(importResult.customNames)[0];
                    const sampleDevice = importResult.customNames[sampleIp];
                    log(`Sample device ${sampleIp}:`);
                    log(`  name: ${sampleDevice.name || 'none'}`);
                    log(`  networkRole: ${sampleDevice.networkRole || 'none'}`);
                    log(`  history entries: ${sampleDevice.history ? sampleDevice.history.length : 0}`);
                    if (sampleDevice.history && sampleDevice.history.length > 0) {
                        log(`  latest change: ${JSON.stringify(sampleDevice.history[0].changes || {})}`);
                    }
                }
                
            } catch (error) {
                addResult(`Error processing file: ${error.message}`, 'error');
                log(`Error: ${error.message}`);
            }
        }

        async function testSampleData() {
            clearResults();
            log('Starting sample data test...');

            // Create comprehensive sample data with device history
            const sampleData = {
                metadata: {
                    exportDate: "2025-01-06T15:30:00.000Z",
                    exportType: "network-scan",
                    hasNetworkTopology: true,
                    ipRange: "10.5.1.1-255"
                },
                devices: {
                    "Cisco": [
                        {
                            ip: "10.5.1.1",
                            status: "online",
                            vendor: "Cisco",
                            mac: "00:11:22:33:44:55",
                            ports: ["22/tcp open", "80/tcp open", "443/tcp open"]
                        }
                    ],
                    "HP": [
                        {
                            ip: "10.5.1.10",
                            status: "online",
                            vendor: "HP",
                            mac: "00:11:22:33:44:66",
                            ports: ["22/tcp open", "161/udp open"]
                        }
                    ]
                },
                customNames: {
                    "10.5.1.1": {
                        name: "Main Gateway",
                        category: "Network Infrastructure",
                        networkRole: "gateway",
                        isMainGateway: true,
                        parentGateway: null,
                        parentSwitch: null,
                        portCount: 24,
                        notes: ["Primary network gateway", "Critical infrastructure"],
                        history: [
                            {
                                timestamp: "2025-01-06 10:30:00",
                                changes: {
                                    name: "Main Gateway",
                                    networkRole: "gateway",
                                    isMainGateway: true
                                }
                            },
                            {
                                timestamp: "2025-01-06 11:15:00",
                                changes: {
                                    portCount: 24,
                                    notes: ["Primary network gateway", "Critical infrastructure"]
                                }
                            }
                        ]
                    },
                    "10.5.1.10": {
                        name: "Core Switch",
                        category: "Network Infrastructure",
                        networkRole: "switch",
                        isMainGateway: false,
                        parentGateway: "10.5.1.1",
                        parentSwitch: null,
                        portCount: 48,
                        notes: ["Core network switch"],
                        history: [
                            {
                                timestamp: "2025-01-06 10:45:00",
                                changes: {
                                    name: "Core Switch",
                                    networkRole: "switch",
                                    parentGateway: "10.5.1.1"
                                }
                            },
                            {
                                timestamp: "2025-01-06 12:00:00",
                                changes: {
                                    portCount: 48
                                }
                            }
                        ]
                    }
                }
            };

            try {
                log('Testing sample data with comprehensive device history...');
                
                // Test the import function
                const importResult = parseJSONImport(sampleData);
                
                addResult('✓ Sample data import completed successfully', 'success');
                
                // Verify device history preservation
                const gateway = importResult.customNames["10.5.1.1"];
                const switchDevice = importResult.customNames["10.5.1.10"];
                
                if (gateway && gateway.history && gateway.history.length === 2) {
                    addResult('✓ Gateway device history preserved (2 entries)', 'success');
                    log(`Gateway history entry 1: ${JSON.stringify(gateway.history[0].changes)}`);
                    log(`Gateway history entry 2: ${JSON.stringify(gateway.history[1].changes)}`);
                } else {
                    addResult('✗ Gateway device history not preserved correctly', 'error');
                }
                
                if (switchDevice && switchDevice.history && switchDevice.history.length === 2) {
                    addResult('✓ Switch device history preserved (2 entries)', 'success');
                    log(`Switch history entry 1: ${JSON.stringify(switchDevice.history[0].changes)}`);
                    log(`Switch history entry 2: ${JSON.stringify(switchDevice.history[1].changes)}`);
                } else {
                    addResult('✗ Switch device history not preserved correctly', 'error');
                }
                
                // Verify network topology preservation
                if (gateway && gateway.networkRole === "gateway" && gateway.isMainGateway === true) {
                    addResult('✓ Gateway network topology properties preserved', 'success');
                } else {
                    addResult('✗ Gateway network topology properties not preserved', 'error');
                }
                
                if (switchDevice && switchDevice.parentGateway === "10.5.1.1" && switchDevice.portCount === 48) {
                    addResult('✓ Switch network relationships preserved', 'success');
                } else {
                    addResult('✗ Switch network relationships not preserved', 'error');
                }
                
                log('Sample data test completed successfully');
                
            } catch (error) {
                addResult(`Error in sample data test: ${error.message}`, 'error');
                log(`Error: ${error.message}`);
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            log('Import Fix Verification Test initialized');
            log('Ready to test device history preservation...');
        });
    </script>
</body>
</html>
